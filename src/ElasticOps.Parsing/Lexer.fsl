{

module Lexer

// Opens methods related to fslex.exe
open Microsoft.FSharp.Text.Lexing
open ElasticOps.Parsing.Structures
open System

let newline (lexbuf: LexBuffer<_>) = 
  lexbuf.StartPos <- lexbuf.StartPos.NextLine

let lexeme = LexBuffer.LexemeString
/// Converts a string into a list of characters.
let explode (s:string) =
    [for c in s -> c]

/// Converts a list of characters into a string.
let implode (xs:char list) =
    let sb = System.Text.StringBuilder(xs.Length)
    xs |> List.iter (sb.Append >> ignore)
    sb.ToString()


let removeQuotes s = s |> explode |> List.tail |> List.rev |> List.tail |> List.rev |> implode

}

let char        = ['a'-'z' 'A'-'Z']   
let digit       = ['0'-'9']   
let int         = '-'?digit+   
let float       = '-'?digit+ '.' digit+   
let identifier  = char(char|digit|['-' '_' '.'])*   
let whitespace  = [' ' '\t']   
let newline     = "\n\r" | '\n' | '\r'  
let boolean     = "true" | "false"
let quote       = ['"']
let string      = quote _* quote

rule tokenize = parse   
| whitespace    { tokenize lexbuf }   
| newline       { lexbuf.EndPos <- lexbuf.EndPos.NextLine; tokenize lexbuf; }   
| int           { INT(Int32.Parse((lexeme lexbuf))) }   
| float         { DECIMAL(Decimal.Parse(lexeme lexbuf)) }   
| '{'           { L_C_BRAC }   
| '}'           { R_C_BRAC }   
| '['           { L_S_BRAC }   
| ']'           { R_S_BRAC }   
| ':'           { SEMICOLON }   
| ','           { COMMA }   
| boolean       { BOOLEAN(Boolean.Parse(lexeme lexbuf))}   
| string		{ STRING(removeQuotes(lexeme lexbuf))}
| eof           { EOF }